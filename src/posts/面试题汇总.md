---
date: 2025-07-08
category:
  - 面试题
tag:
  - 面试题
star: false
sticky: false
---

# 面试题汇总

# 项目相关
## 你的项目中用到了哪些设计模式？
举个例子

1. 单例：比如ioc容器内部的组件默认是单例，比如在zookeeper注册中心，只设置一个zookeeperclient单例对象来负责与zookeeper交互。
2. 代理：rpc服务调用，用户端传递的请求，是先给代理处理再发送请求。这样子用户端只要考虑输入和输出就行，中间的细节和远程调用交给代理去完成。
3. 观察者：远程服务调用涉及到服务端发布服务到zk，那用户如何发现服务，除了第一次读取到缓存，后续的更新就用watcher的类似观察者的模式，当观察到zk的节点变动时，更新缓存。
4. 策略：设计多种算法，在不同的情况可以用不同的算法，比如我们提供多种的负载均衡策略，轮询、随机、一致性哈希。

## TCP粘包和拆包你知道是什么吗？
粘包就是在发送的包比较小时候，为了提高网络利用率，把多个包粘在一起发送。

拆包就是在发送的包比较大的时候，超过了缓存区的大小，就拆成多个包发送。

## NIO是什么？和BIO、IO多路复用的区别？
1. NIO是非阻塞型IO，是相当于BIO也就是阻塞型IO提出的。BIO模型中，IO操作是阻塞的，也就是每个线程负责一个IO，在IO数据没有就绪前，线程是阻塞的。
2. NIO不会阻塞线程，而是去在等待数据的过程中去干其他的事。但是需要不断轮询，查看数据是否准备好。由于需要大量的用户态和内核态的切换，占用CPU时间。
3. Java 中的NIO其实是IO多路复用，IO多路复用把Socket监控权交给内核

# MySQL相关
## 事务的四大特性
1. 一致性，表示数据在执行事务前、执行事务中，执行事务后都是保持一致的。多个事务对同一个数据的读取结果相同。
2. 原子性，表示事务是最小的运行单元，事务内部的命令要么全部完成，要么全部失败。
3. 隔离性，表示不同的事务间不能互相读取未提交的数据。
4. 持久性，一个事务提交过后，对数据库内的数据的影响是持久的，即使数据库发生故障也不会影响数据。

实现原理：存储引擎InnoDB使用undo log 来实现持久性和一致性，使用redo log的回滚机制来实现原子性。使用锁和MVCC机制实现隔离性。



## 事务的隔离级别
1. 读未提交
2. 读已提交
3. 可重复读
4. 串行读

读已提交解决了脏读问题，可重复读解决了不可重复读的问题，串行读解决了幻读问题。

默认等级是可重复读。MVCC机制的Read View。读已提交在每个语句执行前生成数据快照，可重复读实现方法是在事务开启时创建数据快照，这样事务期间都用的是这个Read View，也就能保证数据是一致的。



## 可重复读为什么没有解决幻读问题
+ 针对快照读（普通select），是通过MVCC方式解决幻读，事务执行过程中，一直用的是开始时创建的Read View，即使中途有别的事务插入或删除了一条数据，也看不到。就很好地避免了幻读。
+ 针对当前读（select ... for update，insert，update），是通过加记录锁和间隙锁方式解决幻读，在执行语句时会加锁，如果其他事务在这个范围内插入数据什么的，就会被阻塞。但是在一些情况下，同一个事务中有一个更新操作，会改变其他事务新增的记录的事务id，之后这个事务再使用普通的select就可以查询到这个记录。

![](https://cdn.nlark.com/yuque/0/2025/jpeg/44845078/1742995186676-ff7f9ca2-4d90-4d91-a5e5-75f84740938e.jpeg)

要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加行级别，从而避免其他事务插入一条新记录。



## MySQL的锁
InnoDB支持行级锁和表级锁。默认为行级锁。



按不同类型

共享、排它锁：行级别

意向锁：表级别

间隙锁：锁定一个区间

记录锁：锁定一个行记录







## 


# JVM相关
## JVM的内存划分
![](https://cdn.nlark.com/yuque/0/2025/png/44845078/1743509121863-f2523ea8-2cb4-40c8-9fdd-3b00dcac2577.png)

+ 虚拟机栈作用是存储**当前线程**的执行方法的上下文信息。每个被调用的方法都会生成一个栈帧。栈帧存储局部变量表、操作数栈等信息。
+ 程序计数器存储**当前线程**正在执行的Java方法的JVM指令地址。记录当前的程序实际运行到字节码的具体哪一行了。相当于存储**更细粒度**的执行上下文信息。虚拟机栈存储的是当前执行到哪一个方法，后续还要执行什么方法，程序计数器存储的是执行到方法的哪一个指令。
+ 本地方法栈存放的是Native方法，作用与虚拟机栈类似。
+ 元空间，原来叫方法区，在JDK1.8以后改为元空间。主要存放类相关信息。包括类的信息，常量、静态变量等。属于堆的**逻辑部分**。
+ 堆，被**所有线程**共享。用于存放对象实例。

## JVM堆的组成？
![](https://cdn.nlark.com/yuque/0/2025/png/44845078/1743510143646-760b4582-4581-43db-81ff-48dbf8d7a4cd.png)

大体分为新生代和老年代。

+ 新生代存放新创建的对象。新生代包括Eden和survivor空间。由于大部分的对象都是朝生夕灭，所以在新生代中，Eden的空间占大部分。新创建的对象会分配在Eden中。经过垃圾回收后仍幸存的对象会被复制到survivor区中。注意，两个survivor区，在同一个时刻只有一个被使用，目的是方便进行标记-复制。也就是对Eden和其中一个survivor在进行一轮垃圾回收后，幸存者会被复制到另一个survivor中，原来的这两个空间会被清除。
+ 老年代是存放存活时间久的对象。在新生代在存活过一次或多次minor GC的对象会被移动到老年代。

此外，元空间属于堆的逻辑部分，原来是永久代。元空间现在直接在本地内存中，而不是堆中，解决了永久代的容易出现内存溢出的问题。

大对象区，某些JVM实现中，为大对象专门分配了区域。这类对象直接分配到老年代，避免晋升带来的开销。



## 垃圾回收器有哪些（Serial，Serial old，CMS和G1）
Serial：主要是作用于客户端的新生代，单线程。优点是简单，很专注。采用的是标记-复制算法。

Serial old：serial 的老年代版本。也是简单，用在客户端。采用的是标记-整理。

CMS：常用于服务端，针对的是老年代的回收。CMS采用的是标记-清除算法。并行的。

G1：可用于整个java堆，弱化了代的界限。整体是标记-整理算法。



CMS的具体过程，为什么要用标记-清除？

1. 初始标记。标记一些GC root直接相关联的对象。时间短。需要stop the world
2. 并发标记。时间长，扫描老年代的所有对象进行标记，此时用户线程可以并发工作。不需要stw
3. 重新标记。主要是修正在并发标记过程中，由于用户线程的运行而导致的垃圾的不一致。需要stw。
4. 并发清除。与用户线程并发，执行垃圾清除。不需要stw。也是这一步产生了“浮动垃圾”。

细节点：由于在收集空间的时候，还要与用户线程并发。所以还得预留一些空间给用户线程。

使用标记-清除会在老年代中留下内存碎片，那为什么还要用标记清除，因为标记-整理的话需要额外的时间开销。如果追求最小的停顿时间，可以用标记-清除。之后在内存碎片达到不可忍受的程度再统一进行整理。



G1的流程？特色是什么？

G1的特色是：

1. 引入了分区的概念，弱化了分代的概念。分区是将内存分为大小相等的很多区块，这些区块可以属于新生代、老年代。在清除时，基于区块进行复制。
2. 可以预设停顿时间。使用了只要收集的速度能跟得上消耗的速度，JVM的内存就会动态平衡的理念。
3. 不会有浮动垃圾。

流程是

1. 初始标记
2. 并发标记
3. 最终标记，需要stop the world。
4. 筛选回收。这一步与cms大不相同。G1会根据每个region的回收价值和成本**进行排序**。然后根据用户希望的停顿时间制定回收计划。（并不全部回收，只回收一部分）





# 多线程相关
## volatile关键字是做什么的？
答：

volatile关键字是来保证一个变量对所有线程的可见性。当一个变量标注了volatile关键字，系统会知道他是共享的，所以每次取值都会直接从主内存中取值，而不是从cpu寄存器中取值（对其他线程不可见），并且在更新后立即同步到主内存。volatile还会禁止指令重排序。

## volatile和synchronized有什么区别？适用于什么场景？
答：

volatile可以保证可见性，但不能保证操作的原子性。synchronized则两者都可。因为不能保证原子性，所以不能替代锁的作用。可用来进行标志位控制，单例模式下双重检查锁。

双重检查锁是干什么的？就是在我们获取单例对象时，如果没有对应的对象，就需要创建一个。但是，会出现两个线程同时发现没有该对象并且同时试图创建的情况。因此需要双重检查，在获取锁之后，还要判断一次是否存在该单例。在这里加上**volatile关键字**能确保已经创建了的单例能够被其他线程所看到。

## concurrentHashMap的原理，跟HashMap，HashTable有什么区别。
答：

concurrentHashMap是线程安全的HashMap。<font style="color:rgb(25, 27, 31);">其内部和 HashMap 一样，也是采用了数组 + 链表 + 红黑树的方式来实现。</font>专门用于多线程环境。

HashMap操作过程中都没有加锁，是线程不安全的。

HashTable只在put方法上加上了synchronized，保证插入键值对时阻塞其他线程的插入操作。虽然安全但是性能低下。



1. 用volatile修饰的节点数组，也就是一旦修改，对其他线程是可见的。
2. put方法不再直接用悲观锁锁住，而是用乐观锁和cas算法来保证安全性，并且使用简单优先的更新策略，使用cas尝试更新，失败时再使用synchronized锁保护较复杂的操作。



## 公平锁和非公平锁
答：

在java中公平和非公平的意思是，是否按照先来先出的原则进行调度。公平锁吞吐量会下降很多，但是不会饿死。非公平锁有可能导致饿死。

## 可重入锁是什么意思？java中有哪些可重入锁？
答：

可重入锁的意思是，在一个线程中的多个流程是否能获取同一把锁。目的是为了避免死锁。

java中synchronized和reentraintlock是可重入锁。



## ReentraintLocK
答：

是java提供的一个互斥的可重入锁，提供各种选项。比如选择是非公平还是公平，设置超时条件等。

底层也是AQS。

## AQS是什么？
答：

它是多线程同步器，是并发编程 的根基。主要是一个底层是双向链表的等待队列和一个竞态条件。

AQS 使用一个 volatile 类型的整数变量（state）来表示同步状态。这个状态可以由子类定义其具体意义，例如：

对于独占锁，state 表示锁的持有状态（0 表示未持有，1 表示持有）。

对于共享锁，state 表示当前持有的读锁数量。



## 某个线程同步资源失败了是否阻塞？CAS？
答：

这个指的是不加独占锁的条件下，如果遇到了同步资源失败，CAS（比较和交换）发现已经修改了，这个时候更新资源就会失败。应该怎么办，可以选择阻塞，也可以选择自旋，也就是一直重试CAS。





## 乐观锁和悲观锁？
答：

乐观锁就是做很乐观的判断。认为在拿数据的时候，别人都不会去修改这个数据。所以不上锁。只会在要更新数据的时候，判断，从拿到数据到更新数据的期间，有没有认修改过数据。可以用版本号机制和CAS算法实现。

CAS 是 compare and swap，大部分cpu都有对应的汇编指令。三个操作数，内存V，旧值A，新值B。只有（V）== A，B才会更新到V。否则操作失败。



悲观锁就是做很悲观的判断，认为每次拿数据的时候，别人都会修改数据。所以要在每次拿数据的时候上锁。synchronized就是这个原理。



## 如何把任务不放到阻塞队列中？
答：

1. 队列设置不能放元素，也就是不允许排队。
2. 提高最大线程数。



## ThreadLocal的作用是什么？
答：ThreadLocal修饰的变量是线程局部变量，也就是这个变量是线程独有的，不存在多线程之间共享



## synchronized的原理是什么？
答：

synchronized是一种**监视器**锁，被synchronized的编译后的代码块，前后会加入monitorenter和monitorexit字节码指令，依赖的是操作系统底层的互斥锁。

      执行monitorenter时尝试获取锁，获取到则锁计数器+1。其他竞争的就进入等待队列。

执行monitorexit，锁计数器-1，如果计数器值为0，则锁释放。



## 锁的优化机制（锁升级）
无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁

锁消除：不存在竞争，直接不要锁了。

无锁：

偏向锁：偏向第一个获得锁的线程

轻量级锁：主要通过CAS和自旋。

重量级锁：就是除了有锁的进程外其他全部阻塞。

# Linux相关
## linux中查看内存占用可以用什么命令？
答：

top查看进程的CPU和内存使用情况，也会报告内存的总量和使用情况。

cat /proc/meminfo 读取/proc下的虚拟文件

## 


# AI相关
## 微调适合什么场景
答：

从大的方面来讲，微调的价值在于将“通识能力”转化为“专项能力”。

比如说我们已经有一个使用通用知识训练好的模型，我们要给它引入专业领域知识，就可以使用微调。

比如说我之前做过的闽南语语音识别，就是用了普通话语音识别的网络进行微调的。这样一方面可以节约训练成本，一方面在专业数据较少的情况下也能有比较好的效果。

## 过拟合的概念？
答：

过拟合就是当前模型对当前数据集拟合程度过高，从而导致了泛化能力下降的现象。

通俗来讲，比如目标函数是一个二次函数，但是如果要对训练集追求拟合程度最好，会拟合成四次函数，那么对泛化能力就是灾难性地下降了。

解决方法：

1. 拟合效果太好所以要减少特征数
2. 增大正则化参数
3. 增大训练集

## 训练过模型吗？
1. 论文的第一篇 用柯尔莫哥洛夫-阿诺德网络，也就是KAN解决了时延差定位任务。因为用时延差定位是一个精度敏感、并且实时性要求较高的任务，而KAN正好满足了这个特性。
2. 论文第二篇，

## RAG是什么？
+ 幻觉，1. 大模型的生成内容基于统计概率而并非事实。2. 内容超出训练数据范围。

检索增强生成。将传统的信息检索系统（数据库）的优势与生成式语言大模型的功能结合在一起。以补全大模型的知识库，以减少大模型环境。



+ 检索
+ 增强
+ 生成

## 简要说说Transformer的原理？
Transformer生成的大体原理就是，根据前文的信息，依赖统计概率来预测下一个token**最有可能**是什么。



意义：提出的自注意力机制解决了--长距离依赖关系处理和并行计算







具体步骤

1. 先把文本切分为token，token会被转化成向量。（语义越相近的词语化成的向量在空间中越近）
2. 向量经过注意力机制，会互相直接相互交流，以调整向量的值。例如deep learning model 和 fashion model里的model语义信息是不一样的。注意力机制会根据上下文信息来调整向量的值。

